/*
 Copyright (C) 2016 3NSoft Inc.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation, either version 3 of the License, or (at your option) any later
 version.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.

 You should have received a copy of the GNU General Public License along with
 this program. If not, see <http://www.gnu.org/licenses/>. */

/// <reference path="./web3n.d.ts" />

/**
 * This is a namespace for things used by mail functionality.
 */
declare namespace web3n.asmail {
	
	interface Service {
		
		/**
		 * This returns a promise resolvable to id (address) of a current signed
		 * user.
		 */
		getUserId(): Promise<string>;

		inbox: InboxService;
		
		delivery: DeliveryService;

	}

	interface DeliveryProgress {
		allDone: boolean;
		msgSize: number;
		recipients: {
			[address: string]: {
				done: boolean;
				idOnDelivery?: string;
				err?: RuntimeException
				bytesSent: number;
			}
		};
	}

	interface DeliveryService {
		
		/**
		 * This returns a promise, resolvable to an allowable total size of a
		 * message
		 * @param toAddress
		 */
		preFlight(toAddress: string): Promise<number>;

		/**
		 * This method adds a message for delivery, returning a promise,
		 * resolvable when core accepts message for delivery.
		 * If message requires small amount of network connection, it is set to be
		 * sent immediately. Else, when message is big, or is sent to too many
		 * recipients, it is added to an internal queue for orderly processing.
		 * @param recipients is an array of addresses, where this message should
		 * be sent.
		 * @param msg is a message to be sent
		 * @param id is an id, associated with a given message, for referencing
		 * it in other delivery methods. This id should not be confused with ids,
		 * generated by message accepting servers, associated with each message
		 * delivery.
		 * @param sendImmeditely is a flag, which true value unconditionaly
		 * forces given message to be sent immediately, instead of adding it to
		 * an internal message queue.
		 * Default value for this flag is false.
		 */
		addMsg(recipients: string[], msg: OutgoingMessage, id: string,
			sendImmediately?: boolean): Promise<void>;

		/**
		 * This returns a promise, resolvable to an array of objects, each
		 * carrying message id, used when message was added, and a respective
		 * delivery progress info. This shows all messages currently in a delivery
		 * sub-system, even those with completed delivery process.
		 */
		listMsgs(): Promise<{ id: string; info: DeliveryProgress; }[]>;
		
		/**
		 * This returns a promise, resolvable to current delivery info.
		 * If given id is not known, promise resolves to undefined.
		 * @param id of a message, used when the message was added
		 */
		currentState(id: string): Promise<DeliveryProgress|undefined>;

		/**
		 * This function attaches listeners to observe delivery process of a
		 * particular message. This call returns a detaching function.
		 * Due to immediate subscription, given callbacks become hot.
		 * @param id of a message, used when the message was added
		 * @param observer is an object with at least one of three methods: next,
		 * completed, and error.
		 * Method next it is an on-event callback, called every time there is
		 * an event, which can be zero or more times. This is never called after
		 * either completion, error, or detachment.
		 * Method complete is a callback that is called only once, when event
		 * source says that there will be no more events, i.e. when a normal
		 * completion occurs. Note that this function is not called when detacher
		 * is triggered.
		 * Method error is a callback that is called on error, either coming
		 * from event source, or if onNext throws something, although it must
		 * handle its own stuff.
		 */
		observeDelivery(id: string, observer: Observer<DeliveryProgress>):
			() => void;
		
		/**
		 * This returns a promise, resolvable when the message is removed from a
		 * delivery sub-system.
		 * @param id of a message, used when the message was added
		 * @param cancelSending is a flag, which true value forces delivery
		 * cancelation of a message. With a default false value, message is not
		 * removed, if its delivery process hasn't completed, yet.
		 */
		rmMsg(id: string, cancelSending?: boolean): Promise<void>;

	}

	interface InboxService {
		
		/**
		 * This returns a promise, resolvable to info objects for messages that
		 * are present on a server, timestamped starting with a given time, if it
		 * is given.
		 * @param fromTS an optional timestamp to limit message listing only to
		 * those messages with the same or more recent timestamps.
		 */
		listMsgs(fromTS?: number): Promise<MsgInfo[]>;
		
		/**
		 * This returns a promise, resolvable when a given message has been
		 * removed on the server.
		 * @param msgId
		 */
		removeMsg(msgId: string): Promise<void>;
		
		/**
		 * This returns a promise, resolvable to a message, present on a server.
		 * @param
		 */
		getMsg(msgId: string): Promise<IncomingMessage>;

		/**
		 * This function attaches listeners for a given event, returning a
		 * detaching function.
		 * Due to immediate subscription, given callbacks become hot.
		 * @param event
		 * @param observer is an object with at least one of three methods: next,
		 * completed, and error.
		 * Method next it is an on-event callback, called every time there is
		 * an event, which can be zero or more times. This is never called after
		 * either completion, error, or detachment.
		 * Method complete is a callback that is called only once, when event
		 * source says that there will be no more events, i.e. when a normal
		 * completion occurs. Note that this function is not called when detacher
		 * is triggered.
		 * Method error is a callback that is called on error, either coming
		 * from event source, or if next throws something, although it must
		 * handle its own stuff.
		 */
		subscribe(event: 'message', observer: Observer<IncomingMessage>):
			() => void;
		
	}

	interface MsgStruct {
		/**
		 * Message type can be
		 * (a) "mail" for messages that better be viewed in mail styly UI,
		 * (b) "chat" for messages that better be viewed in chat style UI,
		 * (c) "app:<app-domain>" for application messages, for example, messages
		 * for app with domain app.com should have type "app:app.com".
		 */
		msgType: string;
		subject?: string;
		plainTxtBody?: string;
		htmlTxtBody?: string;
		jsonBody?: any;
		carbonCopy?: string[];
		recipients?: string[];
	}
	
	interface MsgInfo {
		msgId: string;
		msgType: string;
		deliveryTS: number;
	}
	
	interface IncomingMessage extends MsgInfo, MsgStruct {
		sender: string;
		establishedSenderKeyChain: boolean;
		attachments?: files.ReadonlyFS;
	}
	
	interface OutgoingMessage extends MsgStruct {
		msgId?: string;
		attachments?: AttachmentsContainer;
	}
	
	/**
	 * This container is for entities that will be present in attachments
	 * fs/folder of recipient's incoming message.
	 */
	interface AttachmentsContainer {
		files?: {
			[name: string]: files.File;
		};
		folders?: {
			[name: string]: files.FS;
		};
	}
	
	interface InboxException extends RuntimeException {
		type: "inbox";
		msgId?: string;
		msgNotFound?: true;
		objNotFound?: true;
		objId?: string;
		msgIsBroken?: true;
	}
	
	interface ServLocException extends RuntimeException {
		type: 'service-locating';
		address: string;
		domainNotFound?: true;
		noServiceRecord?: true;
	}
	
	interface ASMailSendException extends RuntimeException {
		type: 'asmail-delivery';
		address?: string;
		
		// errors that are due to remote side,
		// these will be placed into ProgressDelivery object
		unknownRecipient?: true;
		senderNotAllowed?: true;
		inboxIsFull?: true;
		badRedirect?: true;
		authFailedOnDelivery?: true;
		msgTooBig?: true;
		allowedSize?: number;
		recipientHasNoPubKey?: true;
		recipientPubKeyFailsValidation?: true;
		
		// errors that are due to this side
		msgCancelled?: true;
	}
	
}
